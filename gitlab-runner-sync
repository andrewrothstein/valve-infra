#!/usr/bin/env python3
# -*- mode: python -*-

from pprint import pprint as pp
import argparse
import gitlab
import json
import os
import sys
import toml


def retrieve_machine_list(database):
    """This is a stub method, when the registration service exists, it
    will be pulled from there rather than read out of my made-up
    file."""
    try:
        with open(database, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        return []


class GitlabRunnerAPI:
    def __init__(self, access_token, runner_registration_token):
        self.gl = gitlab.Gitlab(url='https://gitlab.freedesktop.org',
                                private_token=access_token)
        self.registration_token = runner_registration_token
        for runner in self.gl.runners.list():
            print(f"{runner.description} is registered on the server, "
                  "tagged with:")
            for tag in self.tags(runner.id):
                print(f"\t- {tag}")

    def register(self, name, tags):
        """Register a new runner with the given name and tag list"""
        registration_config = {
            'token': self.registration_token,
            'description': name,
            'tag_list': tags,
            'run_untagged': 'false',
        }
        return self.gl.runners.create(registration_config)

    def unregister(self, runner):
        """Remove the given runner from the server."""
        self.gl.runners.delete(runner.id)

    def find_by_name(self, name):
        """Find a runner with a description matching _name_. Return
        the matching runner structure"""
        for runner in self.gl.runners.list():
            if runner.description == name:
                return runner

    def tags(self, runner_id):
        runner_details = self.gl.runners.get(runner_id)
        return runner_details.tag_list

    def active_jobs(self, runner_id):
        runner_details = self.gl.runners.get(runner_id)
        return runner_details.jobs.list(status='running')

    def set_tags(self, runner_id, tags):
        runner = self.gl.runners.get(runner_id)
        runner.tag_list = tags
        runner.save()


class GitlabConfig:
    DEFAULT_CONFIG = {
        'check_interval': 0,
        'concurrent': 128,
        'session_server': {'session_timeout': 1800}
    }

    def __init__(self, config_path):
        self.config_path = config_path
        try:
            self.config = toml.load(config_path)
        except Exception:
            self.config = GitlabConfig.DEFAULT_CONFIG

        print("local configuration:")
        pp(self.config)

    @property
    def runners(self):
        if "runners" not in self.config:
            self.config["runners"] = []
        return self.config["runners"]

    def find_by_name(self, name):
        for runner in self.runners:
            if runner["name"] == name:
                return runner

    def remove_runner(self, runner):
        self.runners[:] = [r for r in self.runners
                           if r['name'] != runner['name']]

    def add_runner(self, name, token):
        volumes = [
            '/var/run/docker.sock:/var/run/docker.sock',
            '/cache'
        ]
        config = {
            'name': name,
            'limit': 1,
            'url': 'https://gitlab.freedesktop.org/',
            'token': token,
            'executor': 'docker',
            'custom_build_dir': {},
            'cache': {'s3': {}, 'gcs': {}, 'azure': {}},
            'docker': {
                'tls_verify': False,
                'image': 'registry.freedesktop.org/mupuf/valve-infra/gitlab-job-runner',
                'privileged': True,
                'disable_entrypoint_overwrite': False,
                'oom_kill_disable': False,
                'disable_cache': False,
                'volumes': volumes,
                'network_mode': 'host',
                'shm_size': 0
            }
        }
        print("adding a new runner:")
        pp(config)
        self.runners.append(config)
        print("new TOML configuration:")
        pp(toml.dumps(self.config))

    def save(self):
        with open(self.config_path, 'w') as f:
            toml.dump(self.config, f)


def synchronize_machine_runner(machine, gitlab_config, runner_api):
    name, tags = machine["name"], machine["tags"]

    local_runner = gitlab_config.find_by_name(name)
    remote_runner = runner_api.find_by_name(name)

    def register():
        resp = runner_api.register(name, tags)
        gitlab_config.add_runner(name, resp.token)

    if not local_runner and not remote_runner:
        print(f"There is neither a local nor remote runner for {name}."
              "Registering...")
        register()
    elif not local_runner and remote_runner:
        print(f"There is remote runner named {name}, but not local."
              "Deleting remote runner and reregistering...")
        running_jobs = runner_api.active_jobs(remote_runner.id)
        if running_jobs:
            print("""ERROR: The remote runner is actively running
jobs. For now this means you should manually sort that out and come back.""")
            return False
        runner_api.unregister(remote_runner)
        register()
    elif local_runner and not remote_runner:
        print(f"{name} exists locally but not on the remote. Removing locally and reregistering...")
        gitlab_config.remove_runner(local_runner)
        register()
    elif local_runner and remote_runner:
        pass

    # Both sides are in agreement now, make sure the tags are correct.
    local_runner = gitlab_config.find_by_name(name)
    remote_runner = runner_api.find_by_name(name)

    remote_tags = runner_api.tags(remote_runner.id)
    if not set(tags) == set(remote_tags):
        print(f"""
local vs remote tags are out of sync: {machine['tags']} vs
{remote_tags} setting remote tags to local tags...
""")
        runner_api.set_tags(remote_runner.id, tags)

    return True


def valid_dirname(path):
    if os.path.isdir(os.path.dirname(path)):
        return path
    else:
        raise FileNotFoundError(path)


def valid_path(path):
    if os.path.exists(path):
        return path
    else:
        raise FileNotFoundError(path)


def main(args):
    gitlab_config = GitlabConfig(args.gitlab_config)
    runner_api = GitlabRunnerAPI(args.access_token, args.registration_token)
    farm_duts = retrieve_machine_list(args.machine_data)

    pp(farm_duts)
    for machine in farm_duts:
        if not synchronize_machine_runner(machine,
                                          gitlab_config,
                                          runner_api):
            print("An error occurred synchronizing runners. "
                  "No configuration files have been changed.")
            sys.exit(1)

    gitlab_config.save()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description=""""
Keep the farm DUTs and gitlab runners synchronized.

This component deals with three actors,

  1. A GitLab server instance.
  2. A local path to a gitlab-runner TOML configuration.
  3. A registry of known farm DUTs and their metadata.

And then ensures the server instance and the farm configuration are in
agreement about activated runners and their metadata.
""")
    parser.add_argument('--registration-token', type=str,
                        help='GitLab registration token', required=True)
    parser.add_argument('--access-token', type=str,
                        help="API token, generated from the access tokens area of your GitLab project's settings", required=True)
    parser.add_argument('--machine-data', type=str,
                        help="Listing of machines to synchronize as runners",
                        required=True)
    parser.add_argument('--gitlab-config', type=valid_dirname,
                        help="File containing the client TOML configuration, which will be updated by this script",
                        required=True)

    args = parser.parse_args()
    main(args)
