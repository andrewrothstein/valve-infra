#!/bin/bash

# Set errexit to force an exit on error conditions, and pipefail to
# force any failures in a pipeline to create an error condition
set -o errexit
set -o pipefail
#set -o xtrace

# Generate a configuration file based on the default values, or the
# overriding env vars
[ -d ./config/ ] || mkdir ./config/
echo -e "TMP_MOUNT=${TMP_MOUNT:-/mnt/tmp}
PERMANENT_MOUNT=${PERMANENT_MOUNT:-/mnt/permanent}
REGISTRY_MOUNT=${REGISTRY_MOUNT:-/mnt/tmp/registry}
PRIVATE_INTERFACE=${PRIVATE_INTERFACE:-private}
MINIO_ROOT_PASSWORD=`tr -dc _A-Z-a-z-0-9 < /dev/urandom | head -c 32`
MINIO_URL=${MINIO_URL:-http://10.42.0.1:9000}
FARM_NAME=${FARM_NAME:?Must be defined as an environment variable - think of something unique to your farm!}
GITLAB_REGISTRATION_TOKEN=${GITLAB_REGISTRATION_TOKEN:?Must be defined as an environment variable}
GITLAB_ACCESS_TOKEN=${GITLAB_ACCESS_TOKEN:?Must be defined as an environment variable}
" > ./config/prod.env

. ./config/prod.env

[ -d "$TMP_MOUNT" ] || mkdir "$TMP_MOUNT"
[ -d "$PERMANENT_MOUNT" ] || mkdir "$PERMANENT_MOUNT"
[ -d "$REGISTRY_MOUNT" ] || mkdir "$REGISTRY_MOUNT"

[ -e /sys/class/net/$PRIVATE_INTERFACE ] || ( echo "PRIVATE_INTERFACE ($PRIVATE_INTERFACE) does not exist" && exit 1 )

D=$(dirname $(readlink -f $0))
PRIVATE_IP=$(ip -f inet addr show $PRIVATE_INTERFACE | awk '/inet / {print $2}')
# Strip off the subnet
PRIVATE_HOST=${PRIVATE_IP%%/*}
# Todo, abstract 10.42.0.1
# Not trivial, because of externals like gitlab-trigger (how to
# pass the config to that container?)
if [ "$PRIVATE_HOST" != "10.42.0.1" ]; then
    echo "WARNING: The private interface ($PRIVATE_INTERFACE) has an unexpected IP address"
    echo "Assigned address: ${PRIVATE_HOST}"
    echo "Expected 10.42.0.1"
    echo "Adding 10.42.0.1"
    ip addr add 10.42.0.1/24 dev ${PRIVATE_INTERFACE}
fi

MARS_SECRET_KEYFILE=$PERMANENT_MOUNT/mars_secret_key
if [ ! -e $MARS_SECRET_KEYFILE ]; then
    python3 -c "import secrets ; print(secrets.token_urlsafe())" > $MARS_SECRET_KEYFILE
fi
export MARS_SECRET_KEY=$(<$MARS_SECRET_KEYFILE)

log(){
    echo "valve-infra: $*"
}
die(){
    log "FATAL error: $*"
    exit 1
}

upload_to_minio_if_missing() {
    url="$1"
    path="minio$2"

    mcli stat $path > /dev/null 2> /dev/null || {
        local_file=`mktemp`
        wget -O "$local_file" "$url"
        mcli cp "$local_file" "$path"
        rm "$local_file"
    }
}

if [ ! -n "$VALVE_INFRA_NO_PULL" ]; then
    docker-compose --env-file ./config/prod.env pull
fi
docker-compose --env-file ./config/prod.env up --remove-orphans -d

stop_infra(){
    log "stopping the infra in response to an error condition..."
    docker-compose stop
}
trap stop_infra SIGTERM SIGINT ERR

# Todo, move the below to executor/boots - the entrypoint should really be
# attached to the process manager here

# Download a default kernel and initramfs for our infra
upload_to_minio_if_missing https://gitlab.freedesktop.org/mupuf/boot2container/-/releases/v0.7/downloads/initramfs.linux_amd64.cpio.xz /boot/boot2container_2021_04_22.cpio.xz
mcli cp minio/boot/boot2container_2021_04_22.cpio.xz minio/boot/default_boot2container.cpio.xz

upload_to_minio_if_missing https://gitlab.freedesktop.org/mupuf/valve-infra/-/wikis/uploads/8f749f85b29f6907305b13e1e765a409/bzImage /boot/default_kernel_2021_04_23
mcli cp minio/boot/default_kernel_2021_04_23 minio/boot/default_kernel

docker-compose logs --tail=0 -f || /bin/true

stop_infra()
