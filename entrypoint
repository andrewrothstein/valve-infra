#!/bin/bash

set -eu

# Generate a configuration file based on the default values, or the overriding
# env vars
[ -d ./config/ ] || mkdir ./config/
echo -e "DNS_SERVER=${DNS_SERVER:-10.0.0.6}
TMP_MOUNT=${TMP_MOUNT:-/mnt/tmp}
PERMANENT_MOUNT=${PERMANENT_MOUNT:-/mnt/permanent}
PRIVATE_INTERFACE=${PRIVATE_INTERFACE:-private}
" > ./config/prod.env

cat ./config/private.env >> ./config/prod.env

. ./config/prod.env

D=$(dirname $(readlink -f $0))

if [ ! -d $TMP_MOUNT ]; then
    echo "TMP_MOUNT path ($TMP_MOUNT) is not a directory"
    exit 1
fi

if [ ! -e /sys/class/net/$PRIVATE_INTERFACE ]; then
    echo "PRIVATE_INTERFACE ($PRIVATE_INTERFACE) does not exist"
    exit 1
fi

BOOTS_TOP_LEVEL=${TMP_MOUNT}/boots
[ -d $BOOTS_TOP_LEVEL ] || mkdir -pv $BOOTS_TOP_LEVEL

# Setup the boots service with a prerequisite "default" image.
# This is not done in boots, because that component has no
# responsibilities for image generation.
NFS_ROOTS=$BOOTS_TOP_LEVEL/nfs-roots
[ -d $NFS_ROOTS ] || mkdir -pv $NFS_ROOTS
genroot(){
    ROOTFS=$1
    [ ! -d "$ROOTFS" ] && mkdir -pv "$ROOTFS"

    echo "exporting rootfs..."
    cat <<EOF | docker build -t radv-infra-default-image -
FROM debian:testing
RUN apt-get -qy update && apt-get -qy install --no-install-recommends linux-image-amd64 systemd-sysv
RUN passwd root -d
EOF
    CID=$(docker run -d radv-infra-default-image /bin/true)
    docker export $CID | tar x -C $ROOTFS
    docker stop $CID
}
if [ ! -d  $NFS_ROOTS/default ]; then
    mkdir -v ${NFS_ROOTS}/igalia-amd-gfx8-1
    mkdir -v ${NFS_ROOTS}/igalia-amd-gfx8-2
    # Create something hopefully bootable for stuff not otherwise
    # configured.
    genroot "${NFS_ROOTS}/default"
fi

# This would ideally be in the boots service, but the NFS service will
# fail to start without it, and there's not easy way to depend on
# service setup in docker-compose. (move NFS to boots eventually)
[ -d $BOOTS_TOP_LEVEL/nfs ] || mkdir $BOOTS_TOP_LEVEL/nfs
# NFS needs at least one export to start
# Note that /mnt/tmp/boots/nfs-roots is bind mounted /nfs in the NFS
# server container. This should be less confusing
cat <<EOF >$BOOTS_TOP_LEVEL/nfs/exports
/nfs *(rw,no_all_squash,no_root_squash,no_subtree_check,insecure)
EOF

[ -d $BOOTS_TOP_LEVEL/tftp ] || mkdir -v $BOOTS_TOP_LEVEL/tftp
if [ ! -e $BOOTS_TOP_LEVEL/tftp/pxelinux.0 ] || [ ! -e $BOOTS_TOP_LEVEL/tftp/ldlinux.c32 ]; then
    tmp_dir=$(mktemp -d -t ci-XXXXXXXXXX)
    echo "pxelinux does not exist, recreating..."
    wget -O- 'https://mirrors.edge.kernel.org/pub/linux/utils/boot/syslinux/syslinux-6.03.tar.gz' | tar x -z -f - -C $tmp_dir
    cp -v $tmp_dir/syslinux-6.03/bios/core/pxelinux.0 $BOOTS_TOP_LEVEL/tftp/
    cp -v $tmp_dir/syslinux-6.03/bios/com32/elflink/ldlinux/ldlinux.c32 $BOOTS_TOP_LEVEL/tftp/
    rm -rf $tmp_dir
fi

if [ ! -e $BOOTS_TOP_LEVEL/tftp/ci-bzImage ]; then
    echo "WARNING: No existing kernel, going to populate one I made earlier..."
    cp -v $D/component-farm/tftp/ci-bzImage $BOOTS_TOP_LEVEL/tftp/ci-bzImage
fi

[ -d $BOOTS_TOP_LEVEL/tftp/pxelinux.cfg ] || mkdir -v $BOOTS_TOP_LEVEL/tftp/pxelinux.cfg
if true ; then
    # FIXME: Note the 01- tacked onto the MAC addrs!
    # FIXME: This should be all handled by boots soon
    cat <<EOF > $BOOTS_TOP_LEVEL/tftp/pxelinux.cfg/01-10-62-e5-04-39-89
DEFAULT cikernel
label cikernel
         KERNEL ci-bzImage
         APPEND root=/dev/nfs rw rootfstype=nfs ip=dhcp nfsroot=10.42.0.1:/nfs/igalia-amd-gfx8-1,vers=3 init=/init
EOF
    cat <<EOF > $BOOTS_TOP_LEVEL/tftp/pxelinux.cfg/01-10-62-e5-0e-0a-54
DEFAULT cikernel
label cikernel
         KERNEL ci-bzImage
         APPEND root=/dev/nfs rw rootfstype=nfs ip=dhcp nfsroot=10.42.0.1:/nfs/igalia-amd-gfx8-2,vers=3 init=/init
EOF
    cat <<EOF > $BOOTS_TOP_LEVEL/tftp/pxelinux.cfg/default
DEFAULT def
label def
         KERNEL /nfs/default/vmlinuz
         INITRD /nfs/default/initrd.img
         APPEND root=/dev/nfs rw rootfstype=nfs ip=dhcp nfsroot=10.42.0.1:/nfs/default,vers=3
EOF
fi

# Setup first-time gitlab configuration
if [ -n "$GITLAB_REGISTRATION_TOKEN" ] && [ -n "$GITLAB_ACCESS_TOKEN" ]; then
    [ -d $TMP_MOUNT/gitlab-runner ] || mkdir $TMP_MOUNT/gitlab-runner
    ./gitlab-runner-sync --registration-token $GITLAB_REGISTRATION_TOKEN \
                         --access-token $GITLAB_ACCESS_TOKEN \
                         --machine-data machines.db \
                         --gitlab-config $TMP_MOUNT/gitlab-runner/config.toml
fi

docker-compose --env-file ./config/prod.env pull
docker-compose --env-file ./config/prod.env up
